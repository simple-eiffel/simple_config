<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Architecture - simple_config</title>
    <link rel="stylesheet" href="css/style.css">
</head>
<body>
    <header>
        <div class="logo-container">
            <img src="https://raw.githubusercontent.com/simple-eiffel/claude_eiffel_op_docs/main/artwork/LOGO.png" alt="simple_* logo" class="logo">
        </div>
        <h1>simple_config</h1>
        <p class="tagline">Architecture</p>
    </header>

    <nav>
        <ul>
            <li><a href="index.html">Overview</a></li>
            <li><a href="user-guide.html">User Guide</a></li>
            <li><a href="api-reference.html">API Reference</a></li>
            <li><a href="architecture.html" class="active">Architecture</a></li>
            <li><a href="cookbook.html">Cookbook</a></li>
            <li><a href="https://github.com/simple-eiffel/simple_config">GitHub</a></li>
        </ul>
    </nav>

    <main>
        <section id="overview">
            <h2>Design Overview</h2>
            <p>simple_config is built on top of simple_json, providing a high-level configuration API while leveraging JSON for storage format.</p>

            <h3>Key Design Decisions</h3>
            <ul>
                <li><strong>JSON Storage</strong>: Industry-standard format, human-readable, well-supported</li>
                <li><strong>Dot Notation</strong>: Intuitive nested access without complex path objects</li>
                <li><strong>Environment Fallback</strong>: 12-factor app compatibility</li>
                <li><strong>Immutable Keys</strong>: Keys are strings, values are typed</li>
            </ul>
        </section>

        <section id="class-structure">
            <h2>Class Structure</h2>

<pre><code>SIMPLE_CONFIG
    │
    ├── Creation
    │   ├── make                    -- Empty config
    │   └── make_with_file          -- Load from file
    │
    ├── Access (dot notation reads)
    │   ├── string_value, integer_value, boolean_value, real_value
    │   ├── *_or_default variants
    │   ├── *_or_env variants
    │   └── string_list, integer_list, real_list
    │
    ├── Section Access
    │   └── section                 -- Returns child SIMPLE_CONFIG
    │
    ├── Modification (top-level only)
    │   ├── set_string, set_integer, set_boolean, set_real
    │   ├── set_section
    │   └── remove
    │
    └── File Operations
        ├── load, merge_file
        ├── save, save_to
        └── to_json, to_json_pretty</code></pre>
        </section>

        <section id="data-storage">
            <h2>Data Storage</h2>

            <h3>Internal Representation</h3>
<pre><code><span class="keyword">feature</span> {SIMPLE_CONFIG}
    data: SIMPLE_JSON_OBJECT
        <span class="comment">-- JSON object holding all configuration</span>

    env: EXECUTION_ENVIRONMENT
        <span class="comment">-- Environment variable access</span></code></pre>

            <h3>Why SIMPLE_JSON_OBJECT?</h3>
            <ul>
                <li>Native JSON support for file I/O</li>
                <li>Already handles type coercion</li>
                <li>Pretty-printing built-in</li>
                <li>Validated JSON output</li>
            </ul>
        </section>

        <section id="dot-notation">
            <h2>Dot Notation Implementation</h2>

            <h3>Path Navigation Algorithm</h3>
<pre><code>get_value_at_path (a_path: STRING): <span class="keyword">detachable</span> SIMPLE_JSON_VALUE
    <span class="comment">-- Navigate dot-separated path like "database.host"</span>
<span class="keyword">local</span>
    l_parts: LIST [STRING]
    l_current: <span class="keyword">detachable</span> SIMPLE_JSON_OBJECT
<span class="keyword">do</span>
    <span class="keyword">if</span> <span class="keyword">not</span> a_path.has ('.') <span class="keyword">then</span>
        <span class="comment">-- Simple key lookup</span>
        Result := data.item (a_path)
    <span class="keyword">else</span>
        <span class="comment">-- Split and navigate</span>
        l_parts := a_path.split ('.')
        l_current := data
        <span class="keyword">across</span> l_parts <span class="keyword">as</span> part <span class="keyword">loop</span>
            <span class="keyword">if</span> part is last <span class="keyword">then</span>
                Result := l_current.item (part)
            <span class="keyword">else</span>
                <span class="comment">-- Navigate deeper</span>
                l_current := l_current.item (part).as_object
            <span class="keyword">end</span>
        <span class="keyword">end</span>
    <span class="keyword">end</span>
<span class="keyword">end</span></code></pre>

            <h3>Why Read-Only Dot Notation?</h3>
            <p>Setting nested values with dot notation would require:</p>
            <ul>
                <li>Creating intermediate objects that don't exist</li>
                <li>Deciding behavior when path partially exists</li>
                <li>Complex error handling for type mismatches</li>
            </ul>
            <p>Instead, use <code>set_section</code> for explicit control over nested structure.</p>
        </section>

        <section id="env-fallback">
            <h2>Environment Fallback Design</h2>

            <h3>Priority Chain</h3>
<pre><code>string_value_or_env_or_default (key, env_var, default)
    │
    ├─1─> Check config: string_value (key)
    │     └─> If found: return value
    │
    ├─2─> Check environment: env.item (env_var)
    │     └─> If found: return value
    │
    └─3─> Return default</code></pre>

            <h3>Design Rationale</h3>
            <ul>
                <li><strong>Config First</strong>: File values take precedence for predictability</li>
                <li><strong>Environment Override</strong>: Production can override without file changes</li>
                <li><strong>Safe Defaults</strong>: Application always has a fallback value</li>
            </ul>

            <h3>Integer from Environment</h3>
<pre><code>integer_value_or_env (a_key, a_env_var: STRING; a_default: INTEGER): INTEGER
    <span class="comment">-- Parse integer from env var string</span>
<span class="keyword">do</span>
    <span class="keyword">if</span> has_key (a_key) <span class="keyword">then</span>
        Result := integer_value (a_key)
    <span class="keyword">else</span>
        <span class="keyword">if</span> <span class="keyword">attached</span> env.item (a_env_var) <span class="keyword">as</span> e <span class="keyword">then</span>
            <span class="keyword">if</span> e.is_integer <span class="keyword">then</span>
                Result := e.to_integer
            <span class="keyword">else</span>
                Result := a_default  <span class="comment">-- Not parseable</span>
            <span class="keyword">end</span>
        <span class="keyword">else</span>
            Result := a_default
        <span class="keyword">end</span>
    <span class="keyword">end</span>
<span class="keyword">end</span></code></pre>
        </section>

        <section id="file-merging">
            <h2>File Merging Strategy</h2>

            <h3>Merge Algorithm</h3>
<pre><code>merge_file (a_file_path: STRING)
    <span class="comment">-- Merge another config, overriding existing values</span>
<span class="keyword">do</span>
    <span class="comment">-- Parse other file</span>
    l_other := json.parse_file (a_file_path).as_object

    <span class="comment">-- For each key in other, put into self</span>
    <span class="keyword">across</span> l_other.keys <span class="keyword">as</span> key <span class="keyword">loop</span>
        data.put_value (l_other.item (key), key)
    <span class="keyword">end</span>

    is_modified := True
<span class="keyword">end</span></code></pre>

            <h3>Merge Behavior</h3>
            <table class="api-table">
                <tr>
                    <th>Scenario</th>
                    <th>Result</th>
                </tr>
                <tr>
                    <td>Key exists in both</td>
                    <td>New value overwrites old</td>
                </tr>
                <tr>
                    <td>Key only in base</td>
                    <td>Preserved</td>
                </tr>
                <tr>
                    <td>Key only in merged</td>
                    <td>Added</td>
                </tr>
                <tr>
                    <td>Nested objects</td>
                    <td>Entire object replaced (not deep merged)</td>
                </tr>
            </table>

            <p><strong>Note:</strong> Merge is shallow. To deep-merge nested objects, merge at the section level.</p>
        </section>

        <section id="modification-tracking">
            <h2>Modification Tracking</h2>

            <h3>Purpose</h3>
            <ul>
                <li>Know when to prompt "Save changes?"</li>
                <li>Prevent accidental data loss</li>
                <li>Enable dirty-checking patterns</li>
            </ul>

            <h3>Implementation</h3>
<pre><code>set_string (a_key, a_value: STRING)
    <span class="keyword">do</span>
        data.put_string (a_value, a_key)
        is_modified := True  <span class="comment">-- Track change</span>
    <span class="keyword">ensure</span>
        modified: is_modified
    <span class="keyword">end</span>

save
    <span class="keyword">do</span>
        <span class="comment">-- Write to file</span>
        l_file.put_string (to_json_pretty)
        is_modified := False  <span class="comment">-- Reset flag</span>
    <span class="keyword">ensure</span>
        not_modified: <span class="keyword">not</span> is_modified
    <span class="keyword">end</span></code></pre>
        </section>

        <section id="sections">
            <h2>Section Architecture</h2>

            <h3>Section as Independent Config</h3>
<pre><code>section (a_key: STRING): <span class="keyword">detachable</span> SIMPLE_CONFIG
    <span class="comment">-- Get nested section as separate config object</span>
<span class="keyword">do</span>
    <span class="keyword">if</span> <span class="keyword">attached</span> get_value_at_path (a_key) <span class="keyword">as</span> v <span class="keyword">and then</span> v.is_object <span class="keyword">then</span>
        <span class="keyword">create</span> Result.make
        Result.set_data (v.as_object)
    <span class="keyword">end</span>
<span class="keyword">end</span></code></pre>

            <h3>Section Independence</h3>
            <ul>
                <li>Each section is a full SIMPLE_CONFIG instance</li>
                <li>Can be saved independently</li>
                <li>Can be passed to subsystems</li>
                <li>Changes to section do NOT affect parent (copy semantics)</li>
            </ul>
        </section>

        <section id="type-coercion">
            <h2>Type Coercion</h2>

            <h3>JSON to Eiffel Mapping</h3>
            <table class="api-table">
                <tr>
                    <th>JSON Type</th>
                    <th>Eiffel Type</th>
                    <th>Feature</th>
                </tr>
                <tr>
                    <td>string</td>
                    <td>STRING</td>
                    <td><code>string_value</code></td>
                </tr>
                <tr>
                    <td>number (integer)</td>
                    <td>INTEGER</td>
                    <td><code>integer_value</code></td>
                </tr>
                <tr>
                    <td>number (float)</td>
                    <td>DOUBLE</td>
                    <td><code>real_value</code></td>
                </tr>
                <tr>
                    <td>boolean</td>
                    <td>BOOLEAN</td>
                    <td><code>boolean_value</code></td>
                </tr>
                <tr>
                    <td>array</td>
                    <td>ARRAYED_LIST</td>
                    <td><code>string_list</code>, etc.</td>
                </tr>
                <tr>
                    <td>object</td>
                    <td>SIMPLE_CONFIG</td>
                    <td><code>section</code></td>
                </tr>
            </table>

            <h3>Type Mismatch Handling</h3>
            <p>If the JSON value doesn't match the requested type:</p>
            <ul>
                <li><code>string_value</code>: Returns Void</li>
                <li><code>integer_value</code>: Returns 0</li>
                <li><code>boolean_value</code>: Returns False</li>
                <li><code>real_value</code>: Returns 0.0</li>
            </ul>
            <p>Use <code>has_key</code> first if you need to distinguish "missing" from "wrong type".</p>
        </section>

        <section id="dependencies">
            <h2>Dependencies</h2>

            <h3>Required Libraries</h3>
            <ul>
                <li><strong>simple_json</strong>: JSON parsing, object manipulation, pretty printing</li>
                <li><strong>base</strong>: STRING, ARRAYED_LIST, EXECUTION_ENVIRONMENT</li>
            </ul>

            <h3>Dependency Flow</h3>
<pre><code>simple_config
    │
    └──> simple_json
             │
             └──> base (EiffelStudio)</code></pre>
        </section>
    </main>

    <footer>
        <p>&copy; 2025 simple_* ecosystem. MIT License.</p>
        <p>
            <a href="https://github.com/simple-eiffel/simple_config">GitHub</a> |
            <a href="https://simple-eiffel.github.io">Documentation</a>
        </p>
    </footer>
</body>
</html>
